<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>趁年轻别搞开发&#39;s blog</title>
  
  <subtitle>&lt;script type=&quot;text/javascript&quot; src=&quot;https://api.imjad.cn/hitokoto/?c=&amp;charset=utf-8&amp;length=50&amp;encode=js&amp;fun=sync&amp;source=&quot;&gt;&lt;/script&gt;&lt;div id=&quot;hitokoto&quot;&gt;&lt;script&gt;hitokoto()&lt;/script&gt;</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https:www.yh0729.cn/"/>
  <updated>2019-06-04T07:03:40.000Z</updated>
  <id>https:www.yh0729.cn/</id>
  
  <author>
    <name>yh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux下redis开启远程连接</title>
    <link href="https:www.yh0729.cn/20190603/linux-redis-kqyclj.html"/>
    <id>https:www.yh0729.cn/20190603/linux-redis-kqyclj.html</id>
    <published>2019-06-03T15:36:00.000Z</published>
    <updated>2019-06-04T07:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux下redis开启远程连接"><a href="#linux下redis开启远程连接" class="headerlink" title="linux下redis开启远程连接"></a>linux下redis开启远程连接</h2><p>步骤：<br>1.打开redis.conf文件<code>vim redis.conf</code><br>2.使用<code>/</code>命令搜索 daemonize no 改为 yes<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By default Redis does not run as a daemon. Use 'yes' if you need it.</span></span><br><span class="line"><span class="comment"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span></span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure></p><p>3.搜索bind，注释掉,然后添加<code>bind 0.0.0.0</code><img src="http://" alt><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Examples:</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 ::1</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br></pre></td></tr></table></figure></p><p>4.搜索protected-mode，改为no<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By default protected mode is enabled. You should disable it only if</span></span><br><span class="line"><span class="comment"># you are sure you want clients from other hosts to connect to Redis</span></span><br><span class="line"><span class="comment"># even if no authentication is configured, nor a specific set of interfaces</span></span><br><span class="line"><span class="comment"># are explicitly listed using the "bind" directive.</span></span><br><span class="line">protected-mode no</span><br></pre></td></tr></table></figure></p><p>5.给redis设置密码,别直接添加，先搜索requirepass，确定文件里是否有默认，再修改，保证唯一性<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################## SECURITY ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span></span><br><span class="line"><span class="comment"># commands.  This might be useful in environments in which you do not trust</span></span><br><span class="line"><span class="comment"># others with access to the host running redis-server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This should stay commented out for backward compatibility and because most</span></span><br><span class="line"><span class="comment"># people do not need auth (e.g. they run their own servers).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Warning: since Redis is pretty fast an outside user can try up to</span></span><br><span class="line"><span class="comment"># 150k passwords per second against a good box. This means that you should</span></span><br><span class="line"><span class="comment"># use a very strong password otherwise it will be very easy to break.</span></span><br><span class="line"><span class="comment">#填写你的password</span></span><br><span class="line"> requirepass <span class="string">'123456'</span></span><br></pre></td></tr></table></figure></p><p>6.根据你的配置文件，重启redis<br><code>./redis-server redis.conf</code></p><p>7.可用本地连接测试，也可用redis可视化工具连接<code>./redis-cli -h 127.0.0.1 -p 6379 -a 1234</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@izuf6dtic2d71rbvtn6126z redis-4.0.6]<span class="comment"># ls</span></span><br><span class="line">00-RELEASENOTES  CONTRIBUTING  deps      INSTALL   MANIFESTO  redis.conf  runtest-cluster   sentinel.conf  tests</span><br><span class="line">BUGS             COPYING       dump.rdb  Makefile  README.md  runtest     runtest-sentinel  src            utils</span><br><span class="line">[root@izuf6dtic2d71rbvtn6126z redis-4.0.6]<span class="comment"># cd ./src/</span></span><br><span class="line">[root@izuf6dtic2d71rbvtn6126z src]<span class="comment"># ./redis-cli -h ip地址 -p 6379 -a 密码</span></span><br><span class="line">101.132.191.145:6379&gt; keys *</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">101.132.191.145:6379&gt;</span><br></pre></td></tr></table></figure></p><p><strong>注意：防火墙和服务器安全规则都需要开启redis对应端口</strong></p><h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><p>在redis-cli目录下执行 <code>./redis-cli KEYS &quot;article-*&quot; | xargs redis-cli DEL</code> 删除 article-* 开头的key</p><p>常用命令：<a href="https://www.runoob.com/redis/redis-commands.html" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux下redis开启远程连接&quot;&gt;&lt;a href=&quot;#linux下redis开启远程连接&quot; class=&quot;headerlink&quot; title=&quot;linux下redis开启远程连接&quot;&gt;&lt;/a&gt;linux下redis开启远程连接&lt;/h2&gt;&lt;p&gt;步骤：&lt;br&gt;1.打
      
    
    </summary>
    
      <category term="redis" scheme="https:www.yh0729.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="https:www.yh0729.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mycat的配置和使用</title>
    <link href="https:www.yh0729.cn/20190523/mycat-config.html"/>
    <id>https:www.yh0729.cn/20190523/mycat-config.html</id>
    <published>2019-05-23T09:27:00.000Z</published>
    <updated>2019-06-04T06:52:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mycat的配置和使用"><a href="#Mycat的配置和使用" class="headerlink" title="Mycat的配置和使用"></a>Mycat的配置和使用</h1><h3 id="1-Mycat简介："><a href="#1-Mycat简介：" class="headerlink" title="1. Mycat简介："></a>1. Mycat简介：</h3><p>MyCAT是一款由阿里Cobar演变而来的用于支持数据库，读写分离、分表分库的分布式中间件。MyCAT支持Oracle、MSSQL、MYSQL、PG、DB2关系型数据库，同时也支MongoDB等非关系型数据库。MyCAT原理：MyCAT主要是通过对SQL的拦截，然后经过一定规则的分片解析、路由分析、读写分离分析、缓存分析等，然后将SQL发给后端真实的数据块，并将返回的结果做适当处理返回给客户端。</p><p>分析：所有的数据库请求都将先访问Mycat，由Mycat与数据库交互，数据库将数据返回给程序。实际数据库可能有多个，他们也被称为多节点，或多切片。</p><h3 id="2-windows安装"><a href="#2-windows安装" class="headerlink" title="2.windows安装"></a>2.windows安装</h3><p>下载链接：<a href="http://dl.mycat.io/" rel="external nofollow noopener noreferrer" target="_blank">Mycat</a><br>cmd进入bin目录。</p><blockquote><p>安装: <code>mycat install</code><br>启动：<code>mycat start</code><br>关闭：<code>mycat stop</code></p></blockquote><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><h4 id="3-1-文件目录："><a href="#3-1-文件目录：" class="headerlink" title="3.1 文件目录："></a>3.1 文件目录：</h4><blockquote><p>–bin  启动目录</p></blockquote><blockquote><p>–conf 配置文件存放配置文件的目录：</p></blockquote><blockquote><p>–server.xml：是Mycat服务器参数调整和用户授权的配置文件。</p></blockquote><blockquote><p>–schema.xml：是逻辑库定义和表以及分片定义的配置文件。</p></blockquote><blockquote><p>–rule.xml：  是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改需要重启MyCAT。</p></blockquote><blockquote><p>–log4j.xml： 日志存放在logs/log中，每天一个文件，日志的配置是在conf/log4j.xml中，根据自己的需要可以调整输出级别为debug，debug级别下，会输出更多的信息，方便排查问题。</p></blockquote><blockquote><p>–autopartition-long.txt,partition-hash-int.txt,sequence_conf.properties，sequence_db_conf.properties 分片相关的id分片规则配置文件</p></blockquote><blockquote><p>–lib      MyCAT自身的jar包或依赖的jar包的存放目录。    </p></blockquote><blockquote><p>–logs   MyCAT日志的存放目录。日志存放在logs/log中，每天一个文件</p></blockquote><h4 id="3-2-分表分库"><a href="#3-2-分表分库" class="headerlink" title="3.2 分表分库"></a>3.2 分表分库</h4><p>在server.xml下添加一个用户，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 连接用户名，默认端口是8066 --&gt;</span><br><span class="line">&lt;user name=<span class="string">"yh"</span>&gt;</span><br><span class="line">&lt;!-- 连接密码 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"password"</span>&gt;123456&lt;/property&gt;</span><br><span class="line">&lt;!-- 逻辑数据库名 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"schemas"</span>&gt;MYCAT_DB&lt;/property&gt;</span><br><span class="line">&lt;!-- 开启只读 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"readOnly"</span>&gt;<span class="literal">false</span>&lt;/property&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure><p>运行mycat，使用navicat，输入以上用户名密码，即可连接，连接后即可看到逻辑数据库<br><img src="https://img.yh0729.cn/mycat%E8%BF%9E%E6%8E%A5%E6%88%AA%E5%9B%BE.png" alt="mycat"></p><p>配置schema.xml，配置数据库的表结构，配置分片</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 数据库配置，与server.xml中的数据库对应 --&gt;</span><br><span class="line">&lt;schema name=<span class="string">"MYCAT_DB"</span> checkSQLschema=<span class="string">"false"</span> sqlMaxLimit=<span class="string">"100"</span>&gt;</span><br><span class="line">&lt;!-- user表的两个节点 --&gt;</span><br><span class="line">  &lt;table name=<span class="string">"user"</span> primaryKey=<span class="string">"id"</span> autoIncrement=<span class="string">"true"</span> dataNode=<span class="string">"dn1,dn2"</span> rule=<span class="string">"mod-long"</span>/&gt;</span><br><span class="line">&lt;/schema&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 分片配置 --&gt;</span><br><span class="line">&lt;dataNode name=<span class="string">"dn1"</span> dataHost=<span class="string">"localhost"</span> database=<span class="string">"mycat"</span> /&gt;</span><br><span class="line">&lt;dataNode name=<span class="string">"dn2"</span> dataHost=<span class="string">"remotehost"</span> database=<span class="string">"mycat"</span>/&gt;</span><br><span class="line">&lt;!-- 真实数据库配置 --&gt;</span><br><span class="line">   &lt;dataHost name=<span class="string">"remotehost"</span> maxCon=<span class="string">"1000"</span> minCon=<span class="string">"10"</span> balance=<span class="string">"0"</span> writeType=<span class="string">"0"</span> dbType=<span class="string">"mysql"</span> dbDriver=<span class="string">"native"</span> switchType=<span class="string">"1"</span> slaveThreshold=<span class="string">"100"</span>&gt;</span><br><span class="line">       &lt;heartbeat&gt;select user();&lt;/heartbeat&gt;</span><br><span class="line">       &lt;writeHost host=<span class="string">"db-M1"</span> url=<span class="string">"101.132.191.145:3306"</span> user=<span class="string">"root"</span> password=<span class="string">"1234"</span>&gt;&lt;/writeHost&gt;</span><br><span class="line">   &lt;/dataHost&gt;</span><br><span class="line">&lt;dataHost name=<span class="string">"localhost"</span> maxCon=<span class="string">"1000"</span> minCon=<span class="string">"10"</span> balance=<span class="string">"0"</span> writeType=<span class="string">"0"</span> dbType=<span class="string">"mysql"</span> dbDriver=<span class="string">"native"</span> switchType=<span class="string">"1"</span> slaveThreshold=<span class="string">"100"</span>&gt;</span><br><span class="line">       &lt;heartbeat&gt;select user();&lt;/heartbeat&gt;</span><br><span class="line">       &lt;writeHost host=<span class="string">"db-M2"</span> url=<span class="string">"localhost:3306"</span> user=<span class="string">"root"</span> password=<span class="string">"1234"</span>&gt;&lt;/writeHost&gt;</span><br><span class="line">   &lt;/dataHost&gt;</span><br></pre></td></tr></table></figure><p>修改rule.xml 的mod-long节点数，上面配置了两个节点，所以这里count值为2,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">function</span> name=<span class="string">"mod-long"</span> class=<span class="string">"io.mycat.route.function.PartitionByMod"</span>&gt;</span><br><span class="line">&lt;!-- how many data nodes --&gt;</span><br><span class="line">      &lt;!-- count值与分片个数相同 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"count"</span>&gt;2&lt;/property&gt;</span><br><span class="line">&lt;/<span class="keyword">function</span>&gt;</span><br></pre></td></tr></table></figure></p><p>重启mycat，验证是否生效。在对应两个切片下创建user表，连接逻辑数据库，插入数据，这时会根据节点数取模算法。关于分片取模算法：  根据id进行取模  根据数据库集群的数量（或者说是表数量，mycat里面一个表对应一个库）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">id</span>,<span class="keyword">name</span>,sex) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'anna'</span>,<span class="string">'woman'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">id</span>,<span class="keyword">name</span>,sex) <span class="keyword">values</span> (<span class="number">2</span>,<span class="string">'bob'</span>,<span class="string">'man'</span>);</span><br></pre></td></tr></table></figure></p><p>此时两个节点数据库下各有一条数据(插入数据节点是0开始计算的，意思就是你插入id=1的数据，1%2=1,那就是第二个节点dn2)，大功告成。这时如果在逻辑数据库上执行  <code>select * from user</code>  的原理其实执行的是：<br><code>select * from dn1.user</code>和<code>select * from dn2.user</code>，<br>最后把结果集给mycat进行封装 然后返回给客户端。</p><p>带条件查询：<code>select * from db1.user where id =1</code><br>mycat会进行转换 1%3=1  在dn2上！转换成<code>select * from dn2.user where id = 1</code> ,即一次就能查出结果。</p><p>分页查询：<code>select * from user limit 0,2</code><br>此时它会往两个节点里发送请求（<code>select * from dn1.user limit 0,2</code>  , <code>select * from dn2.user limit 0,2</code>），谁先返回则返回谁的结果（不信可以多运行几次sql）。<br>解决办法：<code>select * from user order by id desc limit 0,1</code>，加上排序后，返回的结果为两个节点所有数据排序后再分页的结果。<br><img src="https://img.yh0729.cn/mycat%E5%88%87%E7%89%87%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2.png" alt="分页查询"></p><h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><p><img src="https://img.yh0729.cn/mycat%E6%8A%A5%E9%94%99.png" alt="find no Route"><br>解决办法：修改schema.xml文件,checkSQLschema=”fasle”,改为true<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;schema name=<span class="string">"MYCAT_DB"</span> checkSQLschema=<span class="string">"true"</span> sqlMaxLimit=<span class="string">"100"</span>&gt;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-Mysql主从复制"><a href="#3-3-Mysql主从复制" class="headerlink" title="3.3 Mysql主从复制"></a>3.3 Mysql主从复制</h4><p>3.3.1 主库配置：<br>1.编辑linux目录下/etc/my.cnf （mysql的配置文件路径）<br><code>vim /etc/my.cnf</code><br>2.在文件的 [mysqld] 下 添加以代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#示开启二进制日志，并把二进制日志前缀改为mysql-bin</span><br><span class="line">log-bin = mysql-bin</span><br><span class="line">#随意数字，只要和从库不相等即可</span><br><span class="line">server-id = 6</span><br><span class="line">#表示需要备份的数据库为test </span><br><span class="line">binlog-do-db = test</span><br><span class="line">#表示需要备份的数据库为mycat下的user表</span><br><span class="line">binlog-do-db = mycat.user</span><br></pre></td></tr></table></figure></p><p>3.在mysql中创建一个用户<br><code>create user &#39;myslave&#39;@&#39;%&#39; identified by &#39;123456&#39;;</code></p><p>4.给myslave用户配置主从复制的权限：<br><code>grant replication slave on *.* to &#39;myslave&#39;@&#39;%&#39; identified by &#39;123456&#39;;</code></p><p>5.刷新权限：<code>flush privileges;</code></p><p>6.查看主服务状态：<code>show master status;</code></p><p>3.3.2从库配置<br>1.编辑mysql安装目录下的my.ini,如果没有自行百度，添加一个my.ini<br>2.在文件my.ini的[mysqld] 下 添加以代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#示开启二进制日志，并把二进制日志前缀改为mysql-bin</span><br><span class="line">log-bin = mysql-bin</span><br><span class="line">#随意数字，只要和主库不相等即可</span><br><span class="line">server-id = 2</span><br><span class="line">#表示需要备份的数据库为test </span><br><span class="line">binlog-do-db = test</span><br><span class="line">#表示需要备份的数据库为mycat下的user表</span><br><span class="line">binlog-do-db = mycat.user</span><br></pre></td></tr></table></figure></p><p> 待续。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mycat的配置和使用&quot;&gt;&lt;a href=&quot;#Mycat的配置和使用&quot; class=&quot;headerlink&quot; title=&quot;Mycat的配置和使用&quot;&gt;&lt;/a&gt;Mycat的配置和使用&lt;/h1&gt;&lt;h3 id=&quot;1-Mycat简介：&quot;&gt;&lt;a href=&quot;#1-Mycat
      
    
    </summary>
    
      <category term="中间件" scheme="https:www.yh0729.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="中间件" scheme="https:www.yh0729.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="sql" scheme="https:www.yh0729.cn/tags/sql/"/>
    
      <category term="mycat" scheme="https:www.yh0729.cn/tags/mycat/"/>
    
  </entry>
  
  <entry>
    <title>算法整理</title>
    <link href="https:www.yh0729.cn/20190522/algorithmic-Arrangement.html"/>
    <id>https:www.yh0729.cn/20190522/algorithmic-Arrangement.html</id>
    <published>2019-05-22T09:51:00.000Z</published>
    <updated>2019-06-05T09:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>闲来无聊，整理了一下各种算法，还没更新完，先写这些吧。。。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序（Selection sort）是一种简单直观的排序算法。</span></span><br><span class="line"><span class="comment">// 它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span></span><br><span class="line"><span class="comment">// 以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">0</span> || arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思路：获取最小的数，放在最前面</span></span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="comment">//获取到最小值的下标</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换位置</span></span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">        System.out.print(x + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//冒泡排序算法的原理如下：</span></span><br><span class="line">    <span class="comment">//比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></span><br><span class="line">    <span class="comment">//对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</span></span><br><span class="line">    <span class="comment">//针对所有的元素重复以上的步骤，除了最后一个。</span></span><br><span class="line">    <span class="comment">//持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span> || arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外层控制需要排序的趟数，内层循环控制 每趟相互比较的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//由于每次比较都会把最大数，放入数组最后，所以每次比较会，i个数都不需要比较了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>] + arr[j];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j] - arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j] - arr[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">        System.out.print(x + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> init_left = left;</span><br><span class="line">    <span class="keyword">int</span> init_right = right;</span><br><span class="line">    <span class="comment">//以数组的第一个数为基准</span></span><br><span class="line">    <span class="keyword">int</span> start = arr[left];</span><br><span class="line">    <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">        <span class="comment">//找到右边比左边小的数，交换位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= start) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = start;</span><br><span class="line">        <span class="comment">//此时从左边开始，找到大于基准值的值，交换位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= arr[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">        arr[left] = start;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"节点值："</span> + left);</span><br><span class="line">    System.out.println(<span class="string">"排序结果："</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    quicksort(arr, init_left, left - <span class="number">1</span>);</span><br><span class="line">    quicksort(arr, right + <span class="number">1</span>, init_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;闲来无聊，整理了一下各种算法，还没更新完，先写这些吧。。。&lt;/p&gt;
&lt;h2 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h2&gt;&lt;figure class=&quot;highlight jav
      
    
    </summary>
    
      <category term="算法" scheme="https:www.yh0729.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https:www.yh0729.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="code" scheme="https:www.yh0729.cn/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习题七：盛最多水的容器</title>
    <link href="https:www.yh0729.cn/20190514/leet0514-sszdrq.html"/>
    <id>https:www.yh0729.cn/20190514/leet0514-sszdrq.html</id>
    <published>2019-05-14T09:14:00.000Z</published>
    <updated>2019-06-05T09:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定n个非负整数a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画n条垂直线，垂直线i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且n的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="图片"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。</p><blockquote><p>示例:输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//短板决定高度*左右间距=最大面积</span></span><br><span class="line">        maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left));</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定n个非负整数a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画n条垂直线，垂直线i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能倾斜容器，且n的值至少为 
      
    
    </summary>
    
      <category term="code" scheme="https:www.yh0729.cn/categories/code/"/>
    
    
      <category term="leetcode" scheme="https:www.yh0729.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习题六：回文数</title>
    <link href="https:www.yh0729.cn/20190514/leet0514-hwspx.html"/>
    <id>https:www.yh0729.cn/20190514/leet0514-hwspx.html</id>
    <published>2019-05-14T07:28:29.000Z</published>
    <updated>2019-06-05T09:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><blockquote><p>示例 1:输入: 121<br>输出: true</p></blockquote><blockquote><p>示例 2:输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。从右向左读, 为 121- 。因此它不是一个回文数。</p></blockquote><blockquote><p>示例 3:输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><p>进阶:你能不将整数转为字符串来解决这个问题吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个数是否是回文数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = x;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        linkedList.add(x % <span class="number">10</span>);</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = linkedList.size();</span><br><span class="line">    Double sum = <span class="number">0</span>d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sum += linkedList.get(i) * Math.pow(<span class="number">10</span>, len - <span class="number">1</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == temp) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 1:输入: 121&lt;br&gt;输出: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 2:输入: -121
      
    
    </summary>
    
      <category term="code" scheme="https:www.yh0729.cn/categories/code/"/>
    
    
      <category term="leetcode" scheme="https:www.yh0729.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习题五：整数反转</title>
    <link href="https:www.yh0729.cn/20190513/leet0513-fz.html"/>
    <id>https:www.yh0729.cn/20190513/leet0513-fz.html</id>
    <published>2019-05-13T09:36:00.000Z</published>
    <updated>2019-06-05T09:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><blockquote><p>示例 1:输入: 123<br>输出: 321</p></blockquote><blockquote><p>示例 2:输入: -123<br>输出: -321</p></blockquote><blockquote><p>示例 3:输入: 120<br>输出: 21</p></blockquote><p>注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//思路：转成字符（总感觉这个办法很傻屌）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    String temp = String.valueOf(x);</span><br><span class="line">    String temp2 = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp.charAt(<span class="number">0</span>) == <span class="string">'-'</span>) &#123;</span><br><span class="line">        temp = temp.substring(<span class="number">1</span>, temp.length());</span><br><span class="line">        temp2 = <span class="string">"-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = temp.length(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        temp2 += temp.charAt(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Long aLong = Long.valueOf(temp2);</span><br><span class="line">    <span class="keyword">if</span> (aLong &lt; -(<span class="number">2</span> &lt;&lt; <span class="number">30</span>) || aLong &gt; (<span class="number">2</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(temp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 1:输入: 123&lt;br&gt;输出: 321&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 2:输入: -123&lt;br&gt;输出: -
      
    
    </summary>
    
      <category term="code" scheme="https:www.yh0729.cn/categories/code/"/>
    
    
      <category term="leetcode" scheme="https:www.yh0729.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习题四：最长公共前缀</title>
    <link href="https:www.yh0729.cn/20190513/leet0513-zcggqz.html"/>
    <id>https:www.yh0729.cn/20190513/leet0513-zcggqz.html</id>
    <published>2019-05-13T06:26:00.000Z</published>
    <updated>2019-06-05T09:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p><blockquote><p>示例 1:输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p></blockquote><blockquote><p>示例 2:输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p></blockquote><p>说明:所有输入只包含小写字母 a-z 。</p><p>个人觉得这个做法很暴力，但是还没想到更好的解决办法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//思路：最长公共前缀 ，最长只能为数组里最短的那个支付串。</span></span><br><span class="line">    <span class="comment">// 1.先找出最短字符串.</span></span><br><span class="line">    <span class="comment">// 2.循环比较：循环最短字符串的长度，和其他字符串比较每个字符是否相等，直到有一个不等则返回前面所有相等的字符</span></span><br><span class="line">    String prefix = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span>(strs.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    String min =strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[i].length() &lt; min.length()) &#123;</span><br><span class="line">            min = strs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strs.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> current = strs[j].charAt(i);</span><br><span class="line">            <span class="keyword">char</span> next = strs[j + <span class="number">1</span>].charAt(i);</span><br><span class="line">            <span class="comment">//如果当前值不等于下一个值，改变flag</span></span><br><span class="line">            <span class="keyword">if</span> (current != next) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止循环</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;br&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 1:输入: [“flower”,”flow”,”flight”]&lt;br&gt;输出: “fl”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;bl
      
    
    </summary>
    
      <category term="code" scheme="https:www.yh0729.cn/categories/code/"/>
    
    
      <category term="leetcode" scheme="https:www.yh0729.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习题三：罗马数字转阿拉伯数字</title>
    <link href="https:www.yh0729.cn/20190513/leet0513-intToRoman.html"/>
    <id>https:www.yh0729.cn/20190513/leet0513-intToRoman.html</id>
    <published>2019-05-13T05:26:00.000Z</published>
    <updated>2019-06-05T09:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:<br>输入: “III”<br>输出: 3</p></blockquote><blockquote><p>示例 2:输入: “IV”<br>输出: 4</p></blockquote><blockquote><p>示例 3:输入: “IX”<br>输出: 9</p></blockquote><blockquote><p>示例 4:输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.</p></blockquote><blockquote><p>示例 5:输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><h5 id="1-罗马数字转阿拉伯数字"><a href="#1-罗马数字转阿拉伯数字" class="headerlink" title="1.罗马数字转阿拉伯数字"></a>1.罗马数字转阿拉伯数字</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//储存所有罗马数字</span></span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"I"</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">"V"</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">"X"</span>, <span class="number">10</span>);</span><br><span class="line">    map.put(<span class="string">"L"</span>, <span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">"C"</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">"D"</span>, <span class="number">500</span>);</span><br><span class="line">    map.put(<span class="string">"M"</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        String s1 = Character.toString(s.charAt(i));</span><br><span class="line">        Integer cur = map.get(s1);</span><br><span class="line">        <span class="comment">//判断这个字符是否是最后一个，避免空指针</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() - <span class="number">1</span> == i) &#123;</span><br><span class="line">            sum += cur;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer next = map.get(Character.toString(s.charAt(i + <span class="number">1</span>)));</span><br><span class="line">            <span class="comment">//当前值如果小于下一个值，则获取这两个罗马数字联合的值</span></span><br><span class="line">        <span class="keyword">if</span> (cur &lt; next) &#123;</span><br><span class="line">            sum += next - cur;</span><br><span class="line">             <span class="comment">//这里由于是计算两个罗马符号的值，所以下一次循环跳过</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//正常情况 则 加上当前值</span></span><br><span class="line">            sum += cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-阿拉伯数字转罗马数字"><a href="#2-阿拉伯数字转罗马数字" class="headerlink" title="2.阿拉伯数字转罗马数字"></a>2.阿拉伯数字转罗马数字</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阿拉伯数字转罗马数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ints[] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    String roman[] = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ints[i] &lt;= num) &#123;</span><br><span class="line">            sb.append(roman[i]);</span><br><span class="line">            num -= ints[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;数值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr
      
    
    </summary>
    
      <category term="code" scheme="https:www.yh0729.cn/categories/code/"/>
    
    
      <category term="leetcode" scheme="https:www.yh0729.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习题二：买卖股票的最佳时机</title>
    <link href="https:www.yh0729.cn/20190508/leet0508-shares.html"/>
    <id>https:www.yh0729.cn/20190508/leet0508-shares.html</id>
    <published>2019-05-08T07:57:00.000Z</published>
    <updated>2019-06-05T09:21:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。</p><blockquote><p>示例 1: 输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>注意利润不能是 7-1 = 6, 因为你不能在买入股票前卖出股票。</p></blockquote><blockquote><p>示例 2: 输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = prices[i];</span><br><span class="line">        <span class="comment">//拿到每一个数，获取后面的数 算出最大差</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= prices.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[j] - x &gt; maxProfit) &#123;</span><br><span class="line">                maxProfit = prices[j] - x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最优解法：一次遍历</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> maxprofit;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> minprice = prices[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">           <span class="comment">//小于最小值则赋值，否则获取差</span></span><br><span class="line">           <span class="keyword">if</span> (prices[i] &lt; minprice) &#123;</span><br><span class="line">               minprice = prices[i];</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;</span><br><span class="line">               <span class="comment">//判断是否是最大差值</span></span><br><span class="line">               maxprofit = prices[i] - minprice;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxprofit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;示例 1: 输入: [7,1,5,3,6,
      
    
    </summary>
    
      <category term="code" scheme="https:www.yh0729.cn/categories/code/"/>
    
    
      <category term="leetcode" scheme="https:www.yh0729.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>linux学习之常用命令，持续更新</title>
    <link href="https:www.yh0729.cn/20190429/linuxcommand.html"/>
    <id>https:www.yh0729.cn/20190429/linuxcommand.html</id>
    <published>2019-04-29T07:32:00.000Z</published>
    <updated>2019-04-29T07:32:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-vim常用命令"><a href="#1-vim常用命令" class="headerlink" title="1.vim常用命令"></a>1.vim常用命令</h3><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>v</td><td>从光标当前位置开始，光标所经过的地方会被选中，再按一下v结束。</td></tr><tr><td>d</td><td>使用v选中后，删除</td></tr><tr><td>y</td><td>选中后，复制</td></tr><tr><td>p</td><td>粘贴</td></tr><tr><td>u</td><td>先esc，再按u撤销</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>i</td><td>插入</td></tr><tr><td>:$</td><td>跳转到文末</td></tr></tbody></table><hr><h3 id="2-多行操作"><a href="#2-多行操作" class="headerlink" title="2.多行操作"></a>2.多行操作</h3><p><strong>2.1 多行删除</strong></p><p>1.首先在命令模式下，输入“<code>：set nu</code>”显示行号；</p><p>2.通过行号确定你要删除的行；</p><p>3.命令输入“<code>：32,65d</code>”,回车键，32-   65行就被删除了，很快捷吧，如果无意中删除错了，可以使用‘<code>u</code>’键恢复（命令模式下）</p><p><strong>2.2 多行注释</strong></p><p>1.首先按esc进入命令行模式下，按下Ctrl + v, 进入列模式；</p><p>2.选定要取消注释的多行；</p><p>3.按下“<code>x</code>”或者“<code>d</code>”。<br>（注意：如果是“//”注释，那需要执行两次该操作，如果是“#”注释，一次即可）</p><hr><h3 id="3-操作文件"><a href="#3-操作文件" class="headerlink" title="3.操作文件"></a>3.操作文件</h3><p><strong>3.1  cd</strong><br><code>cd /home</code>      进入 ‘/ home’ 目录’<br><code>cd ..</code>             返回上一级目录<br><code>cd ../..</code>          返回上两级目录<br><code>cd -</code>               返回上次所在的目录<br><code>pwd</code>              显示工作路径</p><hr><p><strong>3.2 ls</strong><br><code>ls</code>                  查看目录中的文件<br><code>ls -a</code>              显示隐藏文件<br><code>ls -l</code>               显示文件和目录的详细资料</p><hr><p><strong>3.3 mkdir  &amp;&amp; cp &amp;&amp; rm</strong><br><code>mkdir  &#39;xx&#39;</code>    创建名为xx的目录<br><code>mkdir -p /tmp/dir1/dir2</code> 创建一个目录树<br><code>cp file1 file2</code> 复制一个文件<br><code>rm -r  dir1</code> 删除目录，不会删除里面文件<br><code>rm -rf dir1</code> 删除一个叫做 ‘dir1’ 的目录并同时删除其里面内容<br><code>rm -rf dir1 dir2</code> 同时删除两个目录及它们的内容 </p><hr><p><strong>3.3 find</strong><br><code>find / -name file1</code> 从 ‘/‘ 开始进入根文件系统搜索文件和目录，如果find ‘/tmp’ -name file1,则查找tmp下的file1文件<br><code>find / -xdev -name \*.sh</code> 搜索以sh结尾的文件，忽略光驱、捷盘等可移动设备 </p><hr><h3 id="4-操作进程-获取端口号"><a href="#4-操作进程-获取端口号" class="headerlink" title="4.操作进程-获取端口号"></a>4.操作进程-获取端口号</h3><p><code>pgrep tomcat</code> 快速直接查找进程id，查找tomcat的端口号<br><code>pidof  tomcat</code>  同上<br><code>killall  tomcat</code>  一般我们可以使用kill　-9 pid方式杀死一个进程，但是这样就需要先找到这个进程的进程id，实际上我们也可以直接根据名称杀死进程<br><code>pkill   tomcat</code>  同上<br><code>ps -p 21641 -o lstart,etime</code>  查看进程已运行时间：其中21641是你要查看进程的进程id。<br><code>lsof -i:4000</code> 查看都口号4000是哪一个进程占用</p><hr><h3 id="5-操作防火墙"><a href="#5-操作防火墙" class="headerlink" title="5.操作防火墙"></a>5.操作防火墙</h3><p>启动：<code>systemctl start firewalld</code><br>关闭： <code>systemctl stop firewalld</code><br>重启： <code>systemctl restart firewalld</code><br>查看状态： <code>systemctl status firewalld</code><br>开机禁用  ：<code>systemctl disable firewalld</code><br>开机启用  ： <code>systemctl enable firewalld</code></p><p>新增一个开放端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">#说明:</span><br><span class="line">#–zone #作用域</span><br><span class="line">#–add-port=80/tcp #添加端口，格式为：端口/通讯协议</span><br><span class="line">#–permanent 永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure></p><p>配置重新载入：<code>firewall-cmd --reload</code><br>查看所有开放的端口：<code>firewall-cmd --zone=public --list-ports</code><br>查看某个端口是否开放：<code>firewall-cmd --zone=public --query-port=80/tcp</code><br>删除开放的端口：<code>firewall-cmd --zone=public --remove-port=80/tcp --permanent</code></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>df -h</code> 使用df命令可以快速查看各挂载路径磁盘占用情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@izuf6dtic2d71rbvtn6126z tmp]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1        40G   12G   26G  31% /</span><br><span class="line">devtmpfs        905M     0  905M   0% /dev</span><br><span class="line">tmpfs           920M     0  920M   0% /dev/shm</span><br><span class="line">tmpfs           920M  944K  919M   1% /run</span><br><span class="line">tmpfs           920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           184M     0  184M   0% /run/user/0</span><br></pre></td></tr></table></figure></p><p><code>du -h –-max-depth=1 /home(或者-d 1)</code>  当前目录以及各个子目录占用空间大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@izuf6dtic2d71rbvtn6126z tmp]<span class="comment"># du -h –-max-depth=1 /home</span></span><br><span class="line">du: cannot access ‘–-max-depth=1’: No such file or directory</span><br><span class="line">4.0K/home/mycat/.mozilla/extensions</span><br><span class="line">4.0K/home/mycat/.mozilla/plugins</span><br><span class="line">12K/home/mycat/.mozilla</span><br><span class="line">24K/home/mycat</span><br><span class="line">36K/home/jenkins/.java/fonts/1.8.0_171</span><br><span class="line">40K/home/jenkins/.java/fonts</span><br><span class="line">44K/home/jenkins/.java</span><br><span class="line">52K/home/jenkins</span><br><span class="line">80K/home</span><br></pre></td></tr></table></figure></p><p><code>free -h</code> 当前内存使用情况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@izuf6dtic2d71rbvtn6126z tmp]<span class="comment"># free -h</span></span><br><span class="line">total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1.8G        886M         90M        1.0M        861M        746M</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-vim常用命令&quot;&gt;&lt;a href=&quot;#1-vim常用命令&quot; class=&quot;headerlink&quot; title=&quot;1.vim常用命令&quot;&gt;&lt;/a&gt;1.vim常用命令&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;

      
    
    </summary>
    
      <category term="linux" scheme="https:www.yh0729.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="https:www.yh0729.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>leetcode练习题一：判断能否变成递减数列</title>
    <link href="https:www.yh0729.cn/20190426/leet0426-fdjsl.html"/>
    <id>https:www.yh0729.cn/20190426/leet0426-fdjsl.html</id>
    <published>2019-04-26T03:56:00.000Z</published>
    <updated>2019-04-26T03:56:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]</p><blockquote><p>示例 1:输入: [4,2,3]<br>输出: True<br>解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</p></blockquote><blockquote><p>示例 2:输入: [4,2,1]<br>输出: False<br>解释: 你不能在只改变一个元素的情况下将其变为非递减数列。<br>说明: n 的范围为 [1, 10,000]。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断改变一个值是否能变成递增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 3 2 1, 1 2 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">changeOneToUp</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    Boolean flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//2个数是一定可以的</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 5 4 4 6</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//第一个数没有左边的值，所以单独拿出来</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果第一个数大于右边，则count++</span></span><br><span class="line">            <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//第一个重新赋值为较小的数，因为要判断 后面的数是否小于他左边的数</span></span><br><span class="line">                arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left = arr[i - <span class="number">1</span>];</span><br><span class="line">        right = arr[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//此时的值判断是否比右边大，count++</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; right) &#123;</span><br><span class="line">            <span class="comment">//左边比右边大,则此时右边的值只能最小为arr[i]</span></span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//此时 arr[i]，最小值范围在left-right之间，所以赋值最小值：left的值</span></span><br><span class="line">                arr[i] = left;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//count最大只能为1 ，才能符合条件</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &amp;lt;= i &amp;lt; n)，满足 array[i] &amp;lt;= array[i + 1]&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="code" scheme="https:www.yh0729.cn/categories/code/"/>
    
    
      <category term="leetcode" scheme="https:www.yh0729.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>第一篇blog：感悟</title>
    <link href="https:www.yh0729.cn/20190426/sentiment.html"/>
    <id>https:www.yh0729.cn/20190426/sentiment.html</id>
    <published>2019-04-26T03:45:00.000Z</published>
    <updated>2019-04-26T03:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>生活不仅有眼前的苟且，还有未来的打击！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生活不仅有眼前的苟且，还有未来的打击！&lt;/p&gt;

      
    
    </summary>
    
      <category term="生活" scheme="https:www.yh0729.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="苟且" scheme="https:www.yh0729.cn/tags/%E8%8B%9F%E4%B8%94/"/>
    
  </entry>
  
</feed>
